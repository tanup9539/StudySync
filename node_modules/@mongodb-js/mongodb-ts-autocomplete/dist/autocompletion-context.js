"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CachingAutocompletionContext = void 0;
const node_cache_1 = __importDefault(require("node-cache"));
class CachingAutocompletionContext {
    constructor(delegate, cache) {
        this.delegate = delegate;
        this.cache = cache;
        this.cacheOptions = {
            databaseCollectionsTTL: 180,
            collectionSchemaTTL: 180,
            aggregationSchemaTTL: 180,
            ...delegate.cacheOptions,
        };
    }
    static caching(delegate) {
        return new CachingAutocompletionContext(delegate, new node_cache_1.default());
    }
    currentDatabaseAndConnection() {
        return this.delegate.currentDatabaseAndConnection();
    }
    async databasesForConnection(connectionId) {
        const cacheKey = `databasesForConnection::${connectionId}`;
        if (this.cache.has(cacheKey)) {
            return this.cache.get(cacheKey);
        }
        const result = await this.delegate.databasesForConnection(connectionId);
        this.cache.set(cacheKey, result, this.cacheOptions.databaseCollectionsTTL);
        return result;
    }
    async collectionsForDatabase(connectionId, databaseName) {
        const cacheKey = `collectionsForDatabase::${connectionId}::${databaseName}`;
        if (this.cache.has(cacheKey)) {
            return this.cache.get(cacheKey);
        }
        const result = await this.delegate.collectionsForDatabase(connectionId, databaseName);
        this.cache.set(cacheKey, result, this.cacheOptions.databaseCollectionsTTL);
        return result;
    }
    async schemaInformationForCollection(connectionId, databaseName, collectionName) {
        const cacheKey = `schemaInformationForNamespace::${connectionId}::${databaseName}.${collectionName}`;
        if (this.cache.has(cacheKey)) {
            return this.cache.get(cacheKey);
        }
        const result = await this.delegate.schemaInformationForCollection(connectionId, databaseName, collectionName);
        this.cache.set(cacheKey, result, this.cacheOptions.collectionSchemaTTL);
        return result;
    }
}
exports.CachingAutocompletionContext = CachingAutocompletionContext;
//# sourceMappingURL=autocompletion-context.js.map