"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenSet = void 0;
exports.throwIfAborted = throwIfAborted;
exports.withAbortCheck = withAbortCheck;
exports.errorString = errorString;
exports.timeoutSignal = timeoutSignal;
exports.withLock = withLock;
exports.normalizeObject = normalizeObject;
exports.validateSecureHTTPUrl = validateSecureHTTPUrl;
exports.messageFromError = messageFromError;
exports.getRefreshTokenId = getRefreshTokenId;
exports.improveHTTPResponseBasedError = improveHTTPResponseBasedError;
const types_1 = require("./types");
const crypto_1 = require("crypto");
class AbortError extends Error {
    constructor() {
        super('The operation was aborted');
    }
}
function throwIfAborted(signal) {
    if (signal?.aborted)
        throw signal.reason ?? new AbortError();
}
async function withAbortCheck(signal, fn) {
    const signalCheck = () => throwIfAborted(signal);
    let reject;
    const signalPromise = new Promise((resolve, rej) => {
        reject = rej;
    });
    function listener() {
        reject(signal?.reason ?? new AbortError());
    }
    signalPromise.catch(() => {
        /* squelch UnhandledPromiseRejectionWarning */
    });
    signalCheck();
    signal?.addEventListener('abort', listener, { once: true });
    try {
        return await fn({ signalCheck, signalPromise });
    }
    finally {
        signal?.removeEventListener('abort', listener);
    }
}
function errorString(err) {
    return String(typeof err === 'object' && err && 'message' in err ? err.message : err);
}
// AbortSignal.timeout, but consistently .unref()ed
function timeoutSignal(ms) {
    const controller = new AbortController();
    setTimeout(() => controller.abort(), ms).unref();
    return controller.signal;
}
// Ensure that only one call to the target `fn` is active at a time.
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function withLock(fn) {
    // `lock` represents the completion of the current call to fn(), if any.
    let lock = Promise.resolve();
    return (...args) => {
        const result = lock
            .then(() => fn(...args))
            .finally(() => {
            lock = Promise.resolve();
        });
        lock = result.catch(() => {
            /* handled by caller */
        });
        return result;
    };
}
// Normalize JS objects by sorting keys so that {a:1,b:2} and {b:2,a:1} are equivalent.
// eslint-disable-next-line @typescript-eslint/ban-types
function normalizeObject(obj) {
    return Object.fromEntries(Object.entries(obj).sort());
}
function isURL(url) {
    return Object.prototype.toString.call(url).toLowerCase() === '[object url]';
}
// Throws if the url does not refer to an https: endpoint or a local endpoint, or null or undefined.
function validateSecureHTTPUrl(url, diagnosticId) {
    try {
        // eslint-disable-next-line eqeqeq
        if (url == null)
            return 'http-disallowed';
        if (typeof url !== 'string' && !isURL(url))
            throw new Error(`Expected string or URL object, got ${typeof url} instead`);
        const parsed = isURL(url) ? url : new URL(url);
        if (parsed.protocol === 'https:')
            return 'http-disallowed';
        if (parsed.protocol !== 'http:') {
            throw new Error(`Unknown protocol '${parsed.protocol}' '${String(url)}'`);
        }
        if (!/^(\[::1\]|127(\.\d+){3}|localhost)$/.test(parsed.hostname)) {
            throw new Error(`Need to specify https: when accessing non-local URL '${String(url)}'`);
        }
        return 'http-allowed';
    }
    catch (err) {
        if (!err ||
            typeof err !== 'object' ||
            !('message' in err) ||
            typeof err.message !== 'string') {
            throw err;
        }
        err.message += ` (validating: ${diagnosticId})`;
        throw err;
    }
}
function messageFromError(err) {
    return String(err &&
        typeof err === 'object' &&
        'message' in err &&
        typeof err.message === 'string'
        ? err.message
        : err);
}
const salt = (0, crypto_1.randomBytes)(16);
function getRefreshTokenId(token) {
    if (!token)
        return null;
    // Add a prefix to indicate that this isn't an actual refresh token,
    // that might unnecessarily worry users
    return ('debugid:' + (0, crypto_1.createHash)('sha256').update(salt).update(token).digest('hex'));
}
class TokenSet {
    response;
    expiresAt;
    constructor(response, expiresAt) {
        this.response = response;
        this.expiresAt =
            expiresAt ??
                (() => {
                    const expiresIn = this.response.expiresIn();
                    return expiresIn
                        ? Math.floor(Date.now() / 1000) + expiresIn
                        : undefined;
                })();
    }
    get refreshToken() {
        return this.response.refresh_token;
    }
    get accessToken() {
        return this.response.access_token;
    }
    get idToken() {
        return this.response.id_token;
    }
    get idTokenClaims() {
        return this.response.claims();
    }
    get tokenType() {
        return this.response.token_type;
    }
    // Explicitly expressing the return type of this function is a bit awkward,
    // and since it is only consumed by `fromSerialized`, it's fine to leave it inferred.
    serialize() {
        const expiresIn = this.response.expiresIn();
        const claims = this.response.claims();
        return {
            ...this.response,
            claims: claims ? { ...claims } : undefined,
            expiresAt: this.expiresAt ??
                (expiresIn ? Math.floor(Date.now() / 1000) + expiresIn : undefined),
            expiresIn: undefined,
        };
    }
    static fromSerialized(serialized) {
        const helpers = {
            claims: () => serialized.claims,
            expiresIn: () => serialized.expiresAt &&
                Math.max(0, serialized.expiresAt - Math.floor(Date.now() / 1000)),
        };
        return new this(Object.assign({ ...serialized }, helpers), serialized.expiresAt);
    }
    // Identify a token set based on a hash of its contents
    stableId() {
        const { access_token, id_token, refresh_token, token_type } = this.response;
        return (0, crypto_1.createHash)('sha256')
            .update(JSON.stringify({
            access_token,
            id_token,
            refresh_token,
            token_type,
            expires_at: this.expiresAt,
        }))
            .digest('hex');
    }
}
exports.TokenSet = TokenSet;
// openid-client@6.x has reduced error messages for HTTP errors significantly, reducing e.g.
// an HTTP error to just a simple 'unexpect HTTP response status code' message, without
// further diagnostic information. So if the `cause` of an `err` object is a fetch `Response`
// object, we try to throw a more helpful error.
async function improveHTTPResponseBasedError(err) {
    if (err &&
        typeof err === 'object' &&
        'cause' in err &&
        err.cause &&
        typeof err.cause === 'object' &&
        'status' in err.cause &&
        'statusText' in err.cause &&
        'text' in err.cause &&
        typeof err.cause.text === 'function') {
        try {
            let body = '';
            try {
                body = await err.cause.text();
            }
            catch {
                // ignore
            }
            let errorMessageFromBody = '';
            try {
                const parsed = JSON.parse(body);
                errorMessageFromBody =
                    ': ' + String(parsed.error_description || parsed.error || '');
            }
            catch {
                // ignore
            }
            if (!errorMessageFromBody)
                errorMessageFromBody = `: ${body}`;
            return new types_1.MongoDBOIDCError(`${errorString(err)}: caused by HTTP response ${String(err.cause.status)} (${String(err.cause.statusText)})${errorMessageFromBody}`, { codeName: 'HTTPResponseError', cause: err });
        }
        catch {
            return err;
        }
    }
    return err;
}
//# sourceMappingURL=util.js.map